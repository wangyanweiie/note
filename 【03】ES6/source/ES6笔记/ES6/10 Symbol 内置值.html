<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symbol内置属性</title>
</head>
<body>
    <!-- Symbol内置属性 -->
    <!-----------------------------------------------------------------------
    （1）Symbol.hasInstance 
        当其他对象使用 instanceof 运算符,判断是否为该对象的实例时,会调用这个方法;
    （2）Symbol.isConcatSpreadable
        对象的 Symbol.isConcatSpreadable 属性等于的是一个布尔值,表示该对象用于Array.prototype.concat()时,是否可以展开;
    （3）Symbol.species 
        创建衍生对象时, 会使用该属性;
    （4）Symbol.match 
        当执行 str.match(myObject) 时, 如果该属性存在会调用它, 返回该方法的返回值;
    （5）Symbol.replace 
        当该对象被 str.replace(myObject)方法调用时, 会返回该方法的返回值;
    （6）Symbol.search 
        当该对象被 str.search (myObject)方法调用时, 会返回该方法的返回值;
    （7）Symbol.split 
        当该对象被 str.split(myObject)方法调用时, 会返回该方法的返回值;
    （8）Symbol.iterator 
        对象进行 for...of 循环时, 会调用该方法, 返回该对象的默认遍历器;
    （9）Symbol.toPrimitive 
        该对象被转为原始类型的值时, 会调用该方法, 返回该对象对应的原始类型值;
    （10）Symbol. toStringTag 
        在该对象上面调用 toString 方法时, 返回该方法的返回值;
    （11）Symbol. unscopables 
        该对象指定了使用 with 关键字时, 哪些属性会被 with环境排除;
    -------------------------------------------------------------->
    <script>
        //操控对象使用instanceof判断是否为另一个对象的实例的结果
        class Person{
            static [Symbol.hasInstance](param){
                console.log(param);
                console.log("我来检测类型了");
                //return true;
                return false;
            }
        }
        let o = {};
        console.log(o instanceof Person);
        //设置对象用于Array.prototype.concat()时,是否可以展开
        const arr = [1,2,3];
        const arr2 = [4,5,6];
        //arr2[Symbol.isConcatSpreadable] = true;
        arr2[Symbol.isConcatSpreadable] = false;
        console.log(arr.concat(arr2));
    </script>
</body>
</html>