<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>理解闭包2</title>

</head>
<body>
<!---------------------------------
4、常见的闭包
（1）将函数作为另一个函数的返回值
（2）将函数作为实参传递给另一个函数调用

5、作用
（1）延伸了变量的作用范围：让函数外部可以操作(读写)到函数内部的变量/函数;
（2）延长了局部变量的生命周期：使用函数内部的变量在函数执行完后, 仍然存活在内存中,没有消失;
（3）问题：
    * 函数执行完后, 函数内部声明的局部变量是否还存在？？ 一般是不存在, 只有存在于闭包中的变量才可能存在;
    * 在函数外部能直接访问函数内部的局部变量吗？？       不能, 但我们可以通过闭包让外部操作它;

6、生命周期在嵌套内部函数定义执行完时就产生了
（1）产生: (不是在调用时);
（2）死亡: 在嵌套的内部函数成为垃圾对象时;
--------------------------------------------------------+++++ 2021.08.09：要调用调试才显示闭包？？
----------------------------------------------------------------------------------------------->
<script type="text/javascript">
  //-------将函数作为另一个函数的返回值-------
  function fn1(){
    //此时闭包就已经产生了(由于函数提升,内部函数对象已经创建了)
    var num = 2;
    function fn2(){
      //内部函数引用了外部函数的变量 num
      num++;
      console.log(num);
    };
    return fn2;
  };
   var f = fn1();
  /*由于 fn1返回的是函数 fn2,此时 fn2的函数对象地址被赋值给了 f;
  而 fn2的函数对象本身就在 fn1的内部,此时自然可以访问 fn1中的变量;
  而且即使当 fn2函数执行结束 fn2变量被释放，但其函数对象依旧被 f引用着,没有成为垃圾对象;
  等同于：  
  var f = function(){
    num++;
    console.log(num);
  };*/
  //如果没有闭包 此时函数调用结束 fn2 消失
  f(); // 3
  f(); // 4
  //当包含闭包的函数对象成为垃圾对象时,闭包死亡
  f = null;

  //-------将函数作为实参传递给另一个函数调用-------
  function showDelay(msg, time) {
    setTimeout(function () {
      //内部函数引用了外部函数的变量 msg
      alert(msg);
    }, time)
  };
  showDelay('小王', 2000);

</script>
</body>
</html>